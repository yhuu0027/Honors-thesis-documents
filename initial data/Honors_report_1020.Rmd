---
title: "Honors_thesis_1020_Main results"
author: "Yueheng Hu"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
setwd("/Users/yuehenghu/Desktop/RP/RP")
```

```{r packages, include=FALSE}
library(readxl)
library(ggplot2)
library(tidyverse)
library(tseries)
library(broom)
library(forecast)
library(stargazer)
library(tibble)
library(tidymodels)
library(fpp3)
library(plm)
library(tvReg)
library(dplyr)
library(tidyr)
library(tidyselect)
library(RColorBrewer)
```

# Pre-estimation
## Fill in the missing population data:
```{r}
###raw data########
population <- readxl::read_excel("/Users/yuehenghu/Desktop/RP/RP/population.xlsx")
province <- population$Region[1:30]
pop1 <- readxl::read_excel("/Users/yuehenghu/Desktop/RP/RP/population.xlsx",range = "Sheet2!A1:T31")
pop1 <- t(pop1)
province -> colnames(pop1) 

as_tibble(pop1) %>%
  mutate(Year =rownames(pop1)) %>%
  select(Year, c(province))-> pop_df

pop_df %>%
  mutate(Year = paste0(Year, "-01-01")) %>%
  mutate(Year = ymd(Year)) %>%
  as_tsibble(index = Year)  -> pop_ts
pop_ts

# try auto ARIMA forecasts
foreresults <- matrix(0,30,3)
for (i in c(1:30)) {
  pop2_i<- ts(pop1[,i])
  #kpss.test(pop2_i, null = c("Trend"), lshort = TRUE)
  model <- pop2_i %>%
    auto.arima() %>%
    forecast::forecast(h=3)
  foreresults[i,] <- model$mean
}
foreresults

##Import and vidualize the complete population data####################
pop0 <- as_tibble(readxl::read_excel("/Users/yuehenghu/Desktop/RP/RP/population.xlsx",range = "Sheet1!B1:X31"))
pop0
pop0 <- t(pop0)
pop0
province <- population$Region[1:30]
province
province -> colnames(pop0) 
province

as_tibble(pop0) %>%
  mutate(Year =rownames(pop0)) %>%
  select(Year, c(province))-> pop0_df
pop0_df

Year =rownames(pop0)
as_tibble(pop0)%>%
  mutate(Year = paste0(Year, "-01-01")) %>%
  mutate(Year = ymd(Year)) %>%
  as_tsibble(index = Year)  -> pop0_ts
pop0_ts

pop0_ts %>%
  pivot_longer(col = -Year, names_to = "Province") -> pop0_ts_long
autoplot(pop0_ts_long, divideTime=0.5) +
  theme(legend.position = "none")
pop0_df

pop0_df %>%
  filter(Year <= "1999") -> before2000
pop0_df %>%
  filter(Year > "2000") -> since2000
pop0_df

# plot 10 provinces
ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Beijing, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Beijing, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Beijing Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Tianjin, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Tianjin, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Tianjin Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Hebei, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Hebei, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Hebei Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Shanxi, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Shanxi, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Shanxi Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = `Inner Mongolia`, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = `Inner Mongolia`, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Inner Mongolia Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Liaoning, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Liaoning, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Liaoning Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Jilin, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Jilin, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Jilin Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Heilongjiang, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Heilongjiang, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Heilongjiang Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Shanghai, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Shanghai, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Shanghai Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Jiangsu, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Jiangsu, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Jiangsu Population") 

ggplot() +
  geom_line(aes(x = as.numeric(Year), y = Zhejiang, color = "Backward forecasting (1997-1999)"), data = before2000) +
  geom_line(aes(x = as.numeric(Year), y = Zhejiang, color = "Real data (2000-2019)"), data = since2000)+
  xlab("Year")+
  ylab("Population")+
  ggtitle("Zhejiang Population") 
```

## Load the transformed dataset 
All variables are already in per-capita term, and after log-transformation
```{r include=FALSE}
all_0915 <- read_excel("~/Desktop/RP/all_0915.xlsx", sheet = "Sheet1", range = "B1:K691")

# name the vectors:
colnames(all_0915) <- c("Index","province","year","lco2","lgdp","lgdp2","ff","tech","region","yearstd")
view(all_0915)
```



## Visualizing lco2 over time (log(CO2 per capita))
```{r}
all_0915 %>% 
  ggplot(aes(x =year, y =lco2, colour = province, gg=TRUE)) +
  geom_line()

all_0915 %>% 
  filter(region == "C") %>% 
  ggplot(aes(x = year, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "N") %>% 
  ggplot(aes(x = year, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "E") %>% 
  ggplot(aes(x = year, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "NE") %>% 
  ggplot(aes(x = year, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "NW") %>% 
  ggplot(aes(x = year, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "S") %>% 
  ggplot(aes(x = year, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "SW") %>% 
  ggplot(aes(x = year, y = lco2, colour = province)) +
  geom_line()


```
## Visualizing lgdp over time (log(GDP per capita))
```{r}
all_0915 %>% 
  ggplot(aes(x =year, y =lgdp, colour = province, gg=TRUE)) +
  geom_line()

all_0915 %>% 
  filter(region == "C") %>% 
  ggplot(aes(x = year, y = lgdp, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "N") %>% 
  ggplot(aes(x = year, y = lgdp, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "E") %>% 
  ggplot(aes(x = year, y = lgdp, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "NE") %>% 
  ggplot(aes(x = year, y = lgdp, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "NW") %>% 
  ggplot(aes(x = year, y = lgdp, colour = province)) +
  geom_line()


all_0915 %>% 
  filter(region == "S") %>% 
  ggplot(aes(x = year, y = lgdp, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "SW") %>% 
  ggplot(aes(x = year, y = lgdp, colour = province)) +
  geom_line()
```

## Plot lco2 against lgdp
```{r}
all_0915 %>% 
  ggplot(aes(x = lgdp, y = lco2, colour = province, gg=TRUE)) +
  geom_line()

all_0915 %>% 
  filter(region == "C") %>% 
  ggplot(aes(x = lgdp, y = lco2, colour = province, gg=TRUE)) +
  geom_line()

all_0915 %>% 
  filter(region == "N") %>% 
  ggplot(aes(x = lgdp, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "E") %>% 
  ggplot(aes(x = lgdp, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "NE") %>% 
  ggplot(aes(x = lgdp, y = lco2, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "NW") %>% 
  ggplot(aes(x = lgdp, y = lco2, colour = province)) +
  geom_line()


all_0915 %>% 
  filter(region == "S") %>% 
  ggplot(aes(x = lgdp, y = lco2, colour = province)) +
  geom_line()


all_0915 %>% 
  filter(region == "SW") %>% 
  ggplot(aes(x = lgdp, y = lco2, colour = province)) +
  geom_line()


```
## Plot ffindex against year

```{r}
all_0915 %>% 
  ggplot(aes(x = year, y = ff, colour = province, gg=TRUE)) +
  geom_line()

all_0915 %>% 
  filter(region == "C") %>% 
  ggplot(aes(x = year, y = ff, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "N") %>% 
  ggplot(aes(x = year, y = ff, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "E") %>% 
  ggplot(aes(x = year, y = ff, colour = province)) +
  geom_line()


all_0915 %>% 
  filter(region == "NE") %>% 
  ggplot(aes(x = year, y = ff, colour = province)) +
  geom_line()


all_0915 %>% 
  filter(region == "NW") %>% 
  ggplot(aes(x = year, y = ff, colour = province)) +
  geom_line()



all_0915 %>% 
  filter(region == "S") %>% 
  ggplot(aes(x = year, y = ff, colour = province)) +
  geom_line()



all_0915 %>% 
  filter(region == "SW") %>% 
  ggplot(aes(x = year, y = ff, colour = province)) +
  geom_line()

```
## plot tech against year:
```{r}
all_0915 %>% 
  ggplot(aes(x = year, y = tech, colour = province, gg=TRUE)) +
  geom_line()

all_0915 %>% 
  filter(region == "C") %>% 
  ggplot(aes(x = year, y = tech, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "N") %>% 
  ggplot(aes(x = year, y = tech, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "E") %>% 
  ggplot(aes(x = year, y = tech, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "NE") %>% 
  ggplot(aes(x = year, y = tech, colour = province)) +
  geom_line()

all_0915 %>% 
  filter(region == "NW") %>% 
  ggplot(aes(x = year, y = tech, colour = province)) +
  geom_line()


all_0915 %>% 
  filter(region == "S") %>% 
  ggplot(aes(x = year, y = tech, colour = province)) +
  geom_line()


all_0915 %>% 
  filter(region == "SW") %>% 
  ggplot(aes(x = year, y = tech, colour = province)) +
  geom_line()



```


##Split the sample into training and testing sets:
- data before 2016: to fit the model;
- data from 2017 to 2019: to compare with prediction by the proposed model

```{r }
ff<-all_0915$ff
tech<-all_0915$tech
a <- filter(all_0915, year<=2016)
```

# Priliminary analysis
## 3D: Additive smoother
```{r}
library(mgcv)
library(visreg)
fit4 <- gam(lco2~s(lgdp, year), data=all_0915)

visreg2d(fit4,"lgdp","year",  nn=99, plot.type="persp", 
         ylab="\n\nyear", zlab="\n\nf(lgdp,year)") 
visreg(fit4,"lgdp", cond=list(year=1997),  gg=TRUE)
visreg(fit4,"lgdp", cond=list(year=2019),  gg=TRUE)
```

# FE and TVFE estimation for 7 regions
# C (3)
```{r}
e_0915 <- read_excel("~/Desktop/RP/all_0915.xlsx", sheet = "C", range = "C1:K70")
# name the vectors:
colnames(e_0915) <- c("province","year","lco2","lgdp","lgdp2","ff","tech","region","yearstd")
e <- filter(e_0915, year<=2016)
ff<-e$ff
tech<-e$tech
```

### FE
```{r}
mod.fe <- plm::plm(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"), model="within", data=e)
summary(mod.fe)
mod.fe.CI <- confint(mod.fe, level = 0.68)
mod.fe.CI 
```

### TVFE
Kernel: Gaussian
Bandwidth: 0.6
Method: within 
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="within", bw =NULL, tkernel="Gaussian")
# Bootstrapping to get 95% confidence intervals
mod.tvfe.CI <- confint(mod.tvfe, level = 0.68)
mod.tvfe.CI
```
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=3
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```

# Post-estimation
## 1) Comparison plot of the within estimators
```{r}
# see the time-varying pattern of the linear term's parameter:
plot(mod.tvfe.CI, vars = 1, ylim = c(1.5, 2.5))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), ylim = c(1.5, 2.5), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[1, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[1, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")

# see the time-varying pattern of the quadratic term's parameter:
plot(mod.tvfe.CI, vars = 2, ylim = c(-0.6, -0.2))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), ylim =c(-0.6, -0.2), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[2, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[2, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")
```

```{r}
# see the estimated trend function:
plot(mod.tvfe.CI, vars = 5, ylim = c(-5, 0))
graphics::par(mfrow = c(1, 5),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
```
## 2) in-sample forecasting MSE
```{r}
fittedtvfe <- mod.tvfe$fitted
MSE_fe <- mean((mod.fe$residuals)^2)
MSE_fe
MSE_tvfe <- mean((mod.tvfe$residuals)^2)
MSE_tvfe
```
## 3) Residual's ACF
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=3
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```


## 4) 3-steps out-of-sample predition MSE (to forecast the log(CO2) value in year 2017,2018 and 2019)
TVFE:
```{r}
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech","yearstd")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech","yearstd")
  forca =c(0,0,0)
  forca <- forecast(mod.tvfe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```
FE:
```{r}
mod.tvfe <- tvReg::tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="pooling", bw = NULL, tkernel="Gaussian")
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech","yearstd")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech","yearstd")
  forca =c(0,0,0)
  forca <- forecast(mod.tvfe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```

#E (7) (K162)
```{r }
e_0915 <- read_excel("~/Desktop/RP/all_0915.xlsx", sheet = "E", range = "C1:K162")
# name the vectors:
colnames(e_0915) <- c("province","year","lco2","lgdp","lgdp2","ff","tech","region","yearstd")
e <- filter(e_0915, year<=2016)
ff<-e$ff
tech<-e$tech
```
### FE
```{r}
mod.fe <- plm::plm(lco2~lgdp+lgdp2+ff+tech, index = c("province", "year"), model = "within", data=e)
mod.fe.CI <- confint(mod.fe, level = 0.68)
mod.fe.CI 
```

### TVFE
Kernel: Gaussian
Bandwidth: 0.6
Method: within 
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="within", bw =NULL, tkernel="Gaussian")
# Bootstrapping to get 95% confidence intervals
mod.tvfe.CI <- confint(mod.tvfe, level = 0.68)
mod.tvfe.CI
```

# Post-estimation
## 1) Comparison plot of the within estimators
```{r}
# see the time-varying pattern of the linear term's parameter:
plot(mod.tvfe.CI, vars = 1, ylim = c(1, 3))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), ylim = c(1, 3), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[1, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[1, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")

# see the time-varying pattern of the quadratic term's parameter:
plot(mod.tvfe.CI, vars = 2, ylim = c(-1, 0))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), ylim = c(-1, 0), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[2, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[2, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")
```
```{r}
# see the estimated trend function:
plot(mod.tvfe.CI, vars = 5, ylim = c(-5, 0))
graphics::par(mfrow = c(1, 5),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
```

## 2) in-sample forecasting MSE
```{r}
fittedtvfe <- mod.tvfe$fitted
MSE_fe <- mean((mod.fe$residuals)^2)
MSE_fe
MSE_tvfe <- mean((mod.tvfe$residuals)^2)
MSE_tvfe
```

## 3) Residual's ACF
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=7
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```



## 4) 3-steps out-of-sample predition MSE (to forecast the log(CO2) value in year 2017,2018 and 2019)
TVFE:
```{r}
mod.tvfe <- tvReg::tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="pooling", bw = NULL, tkernel="Gaussian")
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech","yearstd")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech","yearstd")
  forca =c(0,0,0)
  forca <- forecast(mod.tvfe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```
FE:
```{r}
library(plm)
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech")
  forca =c(0,0,0)
  forca <- predict(mod.fe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```



# N (5)
```{r }
e_0915 <- read_excel("~/Desktop/RP/all_0915.xlsx", sheet = "N", range = "C1:K116")
# name the vectors:
colnames(e_0915) <- c("province","year","lco2","lgdp","lgdp2","ff","tech","region","yearstd")
e <- filter(e_0915, year<=2016)
ff<-e$ff
tech<-e$tech
```
### FE
```{r}
mod.fe <- plm::plm(lco2~lgdp+lgdp2+ff+tech, index = c("province", "year"), model = "within", data=e)
summary(mod.fe)
mod.fe.CI <- confint(mod.fe, level=0.68)
mod.fe.CI
```

### TVFE
Kernel: Gaussian
Bandwidth: 0.25
Method: Pooling 
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="within", bw = NULL, tkernel="Gaussian")
summary(mod.tvfe)
# Bootstrapping to get 95% confidence intervals
mod.tvfe.CI <- confint(mod.tvfe, level=0.68)
mod.tvfe.CI

```

# Post-estimation
## 1) plot of the within estimators
```{r}
# see the time-varying pattern of the linear term's parameter:
plot(mod.tvfe.CI, vars = 1, ylim = c(0, 7))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), ylim = c(0, 7), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[1, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[1, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")

# see the time-varying pattern of the quadratic term's parameter:
plot(mod.tvfe.CI, vars = 2, ylim = c(-2, 0))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), ylim = c(-2, 0), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[2, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[2, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")
```

## 2) in-sample forecasting-Compare MSE
```{r}
fittedtvfe <- mod.tvfe$fitted
MSE_fe <- mean((mod.fe$residuals)^2)
MSE_fe
MSE_tvfe <- mean((mod.tvfe$residuals)^2)
MSE_tvfe
```

## 3) Residual's ACF
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=5
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```


## 4) 3-steps out-of-sample predition MSE (to forecast the log(CO2) value in year 2017,2018 and 2019)
TVFE:
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="pooling", bw = NULL, tkernel="Gaussian")
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech","yearstd")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech","yearstd")
  forca =c(0,0,0)
  forca <- forecast(mod.tvfe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```
FE:
```{r}
library(plm)
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech")
  forca =c(0,0,0)
  forca <- predict(mod.fe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```



#NE(3)
```{r }
e_0915 <- read_excel("~/Desktop/RP/all_0915.xlsx", sheet = "NE", range = "C1:K70")
# name the vectors:
colnames(e_0915) <- c("province","year","lco2","lgdp","lgdp2","ff","tech","region","yearstd")
e <- filter(e_0915, year<=2016)
ff<-e$ff
tech<-e$tech
```
### FE
```{r}
mod.fe <- plm::plm(lco2~lgdp+lgdp2+ff+tech, index = c("province", "year"), model = "within", data=e)
mod.fe.CI <- confint(mod.fe, level = 0.68)
mod.fe.CI 
```

### TVFE
Kernel: Gaussian
Bandwidth: 0.6
Method: within 
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="within", bw =NULL, tkernel="Gaussian")
# Bootstrapping to get 95% confidence intervals
mod.tvfe.CI <- confint(mod.tvfe, level = 0.68)
mod.tvfe.CI
```
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=3
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```

# Post-estimation
## 1) Comparison plot of the within estimators
```{r}
# see the time-varying pattern of the linear term's parameter:
plot(mod.tvfe.CI, vars = 1, ylim = c(1, 3))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), ylim = c(1, 3), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[1, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[1, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")

# see the time-varying pattern of the quadratic term's parameter:
plot(mod.tvfe.CI, vars = 2, ylim = c(-0.7, 0))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), ylim = c(-0.7, 0), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[2, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[2, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")
```
```{r}
# see the estimated trend function:
plot(mod.tvfe.CI, vars = 5, ylim = c(-5, 0))
graphics::par(mfrow = c(1, 5),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
```
## 2) in-sample forecasting MSE
```{r}
fittedtvfe <- mod.tvfe$fitted
MSE_fe <- mean((mod.fe$residuals)^2)
MSE_fe
MSE_tvfe <- mean((mod.tvfe$residuals)^2)
MSE_tvfe
```

## 3) Residual's ACF
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=3
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```

## 4) 3-steps out-of-sample predition MSE (to forecast the log(CO2) value in year 2017,2018 and 2019)
TVFE:
```{r}
mod.tvfe <- tvReg::tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="within", bw = NULL, tkernel="Gaussian")
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech","yearstd")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech","yearstd")
  forca =c(0,0,0)
  forca <- forecast(mod.tvfe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```
FE:
```{r}
library(plm)
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech")
  forca =c(0,0,0)
  forca <- predict(mod.fe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```



#NW(5)
```{r }
e_0915 <- read_excel("~/Desktop/RP/all_0915.xlsx", sheet = "NW", range = "C1:K116")
# name the vectors:
colnames(e_0915) <- c("province","year","lco2","lgdp","lgdp2","ff","tech","region","yearstd")
e <- filter(e_0915, year<=2016)
ff<-e$ff
tech<-e$tech
```
### FE
```{r}
mod.fe <- plm::plm(lco2~lgdp+lgdp2+ff+tech, index = c("province", "year"), model = "within", data=e)
mod.fe.CI <- confint(mod.fe, level = 0.68)
mod.fe.CI 
```

### TVFE
Kernel: Gaussian
Bandwidth: 0.6
Method: within 
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="within", bw =NULL, tkernel="Gaussian")
# Bootstrapping to get 95% confidence intervals
mod.tvfe.CI <- confint(mod.tvfe, level = 0.68)
mod.tvfe.CI
```

# Post-estimation
## 1) Comparison plot of the within estimators
```{r}
# see the time-varying pattern of the linear term's parameter:
plot(mod.tvfe.CI, vars = 1, ylim = c(1, 3))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), ylim = c(1, 3), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[1, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[1, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")

# see the time-varying pattern of the quadratic term's parameter:
plot(mod.tvfe.CI, vars = 2, ylim = c(-0.7, 0))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), ylim = c(-0.7, 0), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[2, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[2, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")
```
```{r}
# see the estimated trend function:
plot(mod.tvfe.CI, vars = 5, ylim = c(-5, 0))
graphics::par(mfrow = c(1, 5),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
```
## 2) in-sample forecasting MSE
```{r}
fittedtvfe <- mod.tvfe$fitted
MSE_fe <- mean((mod.fe$residuals)^2)
MSE_fe
MSE_tvfe <- mean((mod.tvfe$residuals)^2)
MSE_tvfe
```

## 3) Residual's ACF
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=5
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```


## 4) 3-steps out-of-sample predition MSE (to forecast the log(CO2) value in year 2017,2018 and 2019)
TVFE:
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="pooling", bw = NULL, tkernel="Gaussian")
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech","yearstd")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech","yearstd")
  forca =c(0,0,0)
  forca <- forecast(mod.tvfe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 5, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```
FE:
```{r}
library(plm)
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech")
  forca =c(0,0,0)
  forca <- predict(mod.fe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```


#S (3)
```{r }
e_0915 <- read_excel("~/Desktop/RP/all_0915.xlsx", sheet = "S", range = "C1:K70")
# name the vectors:
colnames(e_0915) <- c("province","year","lco2","lgdp","lgdp2","ff","tech","region","yearstd")
e <- filter(e_0915, year<=2016)
ff<-e$ff
tech<-e$tech
```
### FE
```{r}
mod.fe <- plm::plm(lco2~lgdp+lgdp2+ff+tech, index = c("province", "year"), model = "within", data=e)
mod.fe.CI <- confint(mod.fe, level = 0.68)
mod.fe.CI 
```

### TVFE
Kernel: Gaussian
Bandwidth: 0.6
Method: within 
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="within", bw =NULL, tkernel="Gaussian")
# Bootstrapping to get 95% confidence intervals
mod.tvfe.CI <- confint(mod.tvfe, level = 0.68)
mod.tvfe.CI
```

# Post-estimation
## 1) Comparison plot of the within estimators
```{r}
# see the time-varying pattern of the linear term's parameter:
plot(mod.tvfe.CI, vars = 1, ylim = c(1, 3))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), ylim = c(1, 3), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[1, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[1, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")

# see the time-varying pattern of the quadratic term's parameter:
plot(mod.tvfe.CI, vars = 2, ylim = c(-0.4, 0))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), ylim = c(-0.4, 0), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[2, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[2, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")
```
```{r}
# see the estimated trend function:
plot(mod.tvfe.CI, vars = 5, ylim = c(-5, 0))
graphics::par(mfrow = c(1, 5),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
```

## 2) in-sample forecasting MSE
```{r}
fittedtvfe <- mod.tvfe$fitted
MSE_fe <- mean((mod.fe$residuals)^2)
MSE_fe
MSE_tvfe <- mean((mod.tvfe$residuals)^2)
MSE_tvfe
```

## 3) Residual's ACF
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=3
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```


## 4) 3-steps out-of-sample predition MSE (to forecast the log(CO2) value in year 2017,2018 and 2019)
TVFE:
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="pooling", bw = NULL, tkernel="Gaussian")
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech","yearstd")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech","yearstd")
  forca =c(0,0,0)
  forca <- forecast(mod.tvfe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```
FE:
```{r}
library(plm)
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech")
  forca =c(0,0,0)
  forca <- predict(mod.fe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```


# SW (4)
```{r }
e_0915 <- read_excel("~/Desktop/RP/all_0915.xlsx", sheet = "Western", range = "C1:K93")
# name the vectors:
colnames(e_0915) <- c("province","year","lco2","lgdp","lgdp2","ff","tech","region","yearstd")
e <- filter(e_0915, year<=2016)
ff<-e$ff
tech<-e$tech
```
### FE
```{r}
mod.fe <- plm::plm(lco2~lgdp+lgdp2+ff+tech, index = c("province", "year"), model = "within", data=e)
mod.fe.CI <- confint(mod.fe, level = 0.68)
mod.fe.CI 
```

### TVFE
Kernel: Gaussian
Bandwidth: 0.6
Method: within 
```{r}
mod.tvfe <- tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="within", bw =NULL, tkernel="Gaussian")
# Bootstrapping to get 95% confidence intervals
mod.tvfe.CI <- confint(mod.tvfe, level = 0.68)
mod.tvfe.CI
```

# Post-estimation
## 1) Comparison plot of the within estimators
```{r}
# see the time-varying pattern of the linear term's parameter:
plot(mod.tvfe.CI, vars = 1, ylim = c(1, 3))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), ylim = c(1, 3), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[1, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[1, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[1,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")

# see the time-varying pattern of the quadratic term's parameter:
plot(mod.tvfe.CI, vars = 2, ylim = c(-1, 0))
graphics::par(mfrow = c(1, 1),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
par(new = TRUE)
plot(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), ylim = c(-1, 0), ylab ="", xlab ="", type = "l", xaxt ="n", lty = 2)
graphics::polygon(c(rev(x.axis), x.axis), c(rep(rev(mod.fe.CI[2, 2]), mod.tvfe.CI$obs), rep(mod.fe.CI[2, 1], mod.tvfe.CI$obs)),col = "grey60", border = NA, fillOddEven = TRUE)
lines(x.axis, rep(mean(mod.fe.CI[2,]), mod.tvfe.CI$obs), lty=2)
legend("bottom", c("FE", "TVFE"), lty = 2:1, col = 1, ncol = 2, bty = "n")
```
```{r}
# see the estimated trend function:
plot(mod.tvfe.CI, vars = 5, ylim = c(-5, 0))
graphics::par(mfrow = c(1, 5),
              mar = c(4, 4, 2, 1), oma = c(0, 0, 0, 0)) 
x.axis <- 1:mod.tvfe.CI$obs
```

## 2) in-sample forecasting MSE
```{r}
fittedtvfe <- mod.tvfe$fitted
MSE_fe <- mean((mod.fe$residuals)^2)
MSE_fe
MSE_tvfe <- mean((mod.tvfe$residuals)^2)
MSE_tvfe
```

## 3) Residual's ACF
```{r}
residtvfe <- mod.tvfe$residuals
residtvfe
N=4
# define a matrix to contain TVFE residules:
resid_tvfe= matrix(NA,nrow=N,ncol=20)
# define a vector to contain KPSS test results:
pro_reject <- logical(30)
for (i in (1:N)){
  resid_tvfe[i,] <- residtvfe[(1+20*(i-1)):(20*i)]
  acf(ts(resid_tvfe[i,]))
  # do a kpss test
  data_i = ts(resid_tvfe[i,])
  kpss.test(ts(data_i), null = c("Level"), lshort = TRUE)
  p_value <- kpss.test(ts(data_i))$p.value
  pro_reject[i] <- p_value < .05
}
pro_reject
```

## 4) 3-steps out-of-sample predition MSE (to forecast the log(CO2) value in year 2017,2018 and 2019)
TVFE:
```{r}
mod.tvfe <- tvReg::tvPLM(lco2~lgdp+lgdp2+ff+tech+yearstd, index = c("province", "year"),
                 data = e, method ="pooling", bw = NULL, tkernel="Gaussian")
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech","yearstd")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech","yearstd")
  forca =c(0,0,0)
  forca <- forecast(mod.tvfe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```
FE:
```{r}
library(plm)
pro_list <- unique(e_0915$province)
year_list <- c(2017,2018,2019)
forca_matrix <- c()
for(p in pro_list){ # loop p times
  select_data <- e_0915 %>% 
    filter(province == p) %>% 
    filter( year %in% year_list) %>% 
    select( "lco2","lgdp","lgdp2","ff","tech")
  new_data <- select_data%>% select("lgdp","lgdp2","ff","tech")
  forca =c(0,0,0)
  forca <- predict(mod.fe, newdata = new_data, n.ahead = 3) #1x3 
  forca_matrix <-rbind(forca_matrix,forca) # p x 3 matrix 
}
observe <- e_0915%>%
  filter(year %in% year_list) %>%
  select("lco2")
observe_matrix <- matrix(observe$lco2, nrow = 3, ncol = 3, byrow = TRUE)

MSE = c(0,0,0)

for (j in 1:3){
  MSE[j]= mean((forca_matrix[,j]-observe_matrix[,j])^2)
}

MSE
```


# limitation and future direction

#Heterogeneity panel FE model with a second-order polynomial trend function 
```{r }
N=30
coefficient= matrix(NA,nrow=N,ncol=7)
#resid= matrix(NA,nrow=N,ncol=7)
for (i in (1:N)){
  data_i =  all_0915[all_0915["Index"]==i,c("lco2","lgdp","lgdp2","ff","tech","region")]
  year_std = (1:dim(data_i)[1])/dim(data_i)[1]
  
  est_i =  lm(lco2~lgdp+lgdp2+ff+tech+year_std + I(year_std^2),data=data_i)
  
  coefficient[i,] = est_i$coefficients
  residul_i=est_i$residuals
  fitted_i=est_i$fitted.values
  # residual_i
  #acf(residul_i)
  plot(fitted_i,ylim =c(min(data_i$lco2,fitted_i),max(data_i$lco2,fitted_i)),type='l',col='red')
  lines(data_i$lco2,lty=2)
  legend('bottomright',c('fitted value','data'),lty=c(1,2),col=c('red','black'))
}
coefficient
```






